<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <!-- Assure un affichage correct et emp√™che le zoom par pincement sur mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Geo Tracker</title>
    
    <!-- Charge la feuille de style de Leaflet depuis le dossier local de l'application -->
    <link rel="stylesheet" href="./leaflet.css" />

    <style>
        /* --- Structure G√©n√©rale --- */
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        #map {
            height: 100%;
            width: 100%;
            z-index: 1;
            background-color: #e0e0e0; /* Couleur de fond en attendant la carte */
        }

        /* --- Superposition pour le menu --- */
        #map-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        #map-overlay.visible {
            display: block;
            opacity: 1;
        }

        /* --- Notifications (Toasts) --- */
        #notification-container {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
            pointer-events: none;
            width: 90%;
            max-width: 500px;
        }
        .toast-notification {
            padding: 12px 25px;
            border-radius: 25px;
            color: white;
            background-color: rgba(0, 0, 0, 0.75);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            margin-bottom: 10px;
            opacity: 0;
            transform: translateY(-30px);
            transition: opacity 0.4s ease, transform 0.4s ease;
            text-align: center;
        }
        .toast-notification.show {
            opacity: 1;
            transform: translateY(0);
        }
        .toast-notification.error {
            background-color: #dc3545;
        }

        /* --- Contr√¥les sur la Carte --- */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2;
            display: flex;
            gap: 10px;
        }
        #controls button {
            padding: 15px 20px;
            font-size: 16px;
            border-radius: 50px;
            border: 2px solid #fff;
            background-color: #007BFF;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        /* --- Menu Lat√©ral --- */
        #menu-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 2;
            padding: 10px 15px;
            font-size: 24px;
            border-radius: 50%;
            border: 2px solid #ccc;
            background-color: white;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        #menu {
            position: fixed;
            top: 0;
            left: -300px;
            width: 280px;
            height: 100%;
            background-color: white;
            z-index: 1000;
            transition: left 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
        }
        #menu.open {
            left: 0;
        }
        #menu-header {
            padding: 15px 20px;
            background-color: #f8f9fa;
            border-bottom: 1px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        #menu-header h3 { margin: 0; font-size: 18px; }
        #menu-close { background: none; border: none; font-size: 28px; cursor: pointer; padding: 0 10px; line-height: 1; color: #666; }
        #export-share-container { padding: 20px; background-color: #f8f9fa; }
        #export-share { width: 100%; padding: 15px; background-color: #28a745; color: white; border: none; cursor: pointer; font-size: 16px; }
        #item-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        #item-list li { padding: 15px 20px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }
        #item-list .item-name { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-right: 10px; }
        #item-list .item-actions { display: flex; gap: 8px; }
        #item-list .item-actions button { padding: 5px 10px; border: none; border-radius: 5px; color: white; cursor: pointer; font-size: 14px; }
        .rename-btn { background-color: #007BFF; }
        .delete-btn { background-color: #dc3545; }
        #menu-footer { padding: 20px; border-top: 1px solid #ddd; background-color: #f8f9fa; }
        #delete-all { width: 100%; padding: 15px; background-color: #dc3545; color: white; border: none; cursor: pointer; font-size: 16px; }
        
        /* --- Ic√¥ne de Direction (Fl√®che) --- */
        .direction-arrow {
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 25px solid #007BFF;
            transition: transform 0.2s linear; /* Rotation fluide */
            transform-origin: center 15px; /* Assure que la fl√®che pivote sur sa base */
        }
        .direction-accuracy {
            background-color: rgba(0, 123, 255, 0.1);
            border-radius: 50%;
            border: 1px solid #007BFF;
        }
    </style>
</head>
<body>
    <!-- Structure HTML de l'interface -->
    <div id="notification-container"></div>
    <div id="map"></div>
    <div id="map-overlay"></div>
    <div id="controls">
        <button id="toggle-record">Iniciar Grabaci√≥n</button>
        <button id="add-point">Crear Punto</button>
    </div>
    <button id="menu-toggle">‚ò∞</button>
    <div id="menu">
        <div id="menu-header">
            <h3>Mis Trazados</h3>
            <button id="menu-close">√ó</button>
        </div>
        <div id="export-share-container">
            <button id="export-share">Exportar y Compartir Todo</button>
        </div>
        <ul id="item-list"></ul>
        <div id="menu-footer">
            <button id="delete-all">Borrar Todo</button>
        </div>
    </div>

    <!-- Charge le script de Leaflet depuis le dossier local de l'application -->
    <script src="./leaflet.js"></script>
    
    <script>
        // Attend que toute la page HTML soit charg√©e avant d'ex√©cuter le script
        document.addEventListener('DOMContentLoaded', function() {
            
            // --- SECTION 1 : INITIALISATION ---

            // Initialise la carte Leaflet sans vue par d√©faut, car elle sera d√©finie par l'image
            const map = L.map('map');

            // Variables d'√©tat pour suivre l'application
            let directionMarker, accuracyCircle, isRecording = false;
            let currentTrack;
            let recordedItems = [], itemIdCounter = 0;

            // R√©f√©rences aux √©l√©ments du DOM pour un acc√®s rapide
            const toggleRecordBtn = document.getElementById('toggle-record');
            const addPointBtn = document.getElementById('add-point');
            const menuToggleBtn = document.getElementById('menu-toggle');
            const menu = document.getElementById('menu');
            const menuCloseBtn = document.getElementById('menu-close');
            const mapOverlay = document.getElementById('map-overlay');
            const itemList = document.getElementById('item-list');
            const exportShareBtn = document.getElementById('export-share');
            const deleteAllBtn = document.getElementById('delete-all');
            const notificationContainer = document.getElementById('notification-container');
            

            // --- SECTION 2 : CONFIGURATION DU FOND DE CARTE ---

            // Les coordonn√©es de votre image statique export√©e depuis QGIS
            // Format : [[Latitude_Sud, Longitude_Ouest], [Latitude_Nord, Longitude_Est]]
            const imageBounds = [
                [8.466, -71.678],  // Coin Sud-Ouest: [Y min, X min]
                [8.485, -71.651]   // Coin Nord-Est: [Y max, X max]
            ];

            // Affiche l'image locale comme fond de carte
            L.imageOverlay('map_background.jpg', imageBounds).addTo(map);
            
            // Centre et zoome la carte pour qu'elle corresponde exactement aux dimensions de l'image
            map.fitBounds(imageBounds);


            // --- SECTION 3 : "PONT" DE COMMUNICATION NATIF -> WEB ---

            // Cette fonction est la porte d'entr√©e pour les donn√©es GPS.
            // Elle sera appel√©e par le code natif Android √† chaque nouvelle position.
            window.updatePositionFromNative = function(lat, lng, accuracy) {
                const newLatLng = L.latLng(lat, lng);
                
                // Si la fl√®che de direction n'existe pas, on la cr√©e
                if (!directionMarker) {
                    const arrowIcon = L.divIcon({ className: 'direction-arrow', iconSize: [20, 25], iconAnchor: [10, 25] });
                    directionMarker = L.marker(newLatLng, { icon: arrowIcon }).addTo(map);
                    accuracyCircle = L.circle(newLatLng, { radius: accuracy, className: 'direction-accuracy' }).addTo(map);
                } else {
                    // Sinon, on met simplement √† jour sa position et le cercle de pr√©cision
                    directionMarker.setLatLng(newLatLng);
                    accuracyCircle.setLatLng(newLatLng).setRadius(accuracy);
                }

                // Si l'enregistrement est en cours, on ajoute le point au trac√©
                if (isRecording && currentTrack) {
                    const trackPoints = currentTrack.getLatLngs();
                    // On v√©rifie que le nouveau point n'est pas identique au pr√©c√©dent pour √©viter les doublons
                    if (trackPoints.length === 0 || !newLatLng.equals(trackPoints[trackPoints.length - 1])) {
                        currentTrack.addLatLng(newLatLng);
                    }
                }
            };

            // Cette fonction est la porte d'entr√©e pour les donn√©es de la boussole.
            // Elle sera appel√©e par le code natif Android √† chaque changement d'orientation.
            window.updateHeadingFromNative = function(heading) {
                if (directionMarker && directionMarker.getElement()) {
                    // On applique une transformation CSS pour faire pivoter la fl√®che. C'est tr√®s performant.
                    directionMarker.getElement().style.transform = `rotate(${heading}deg)`;
                }
            };


            // --- SECTION 4 : SAUVEGARDE ET CHARGEMENT (localStorage) ---

            // Sauvegarde la liste des points et parcours dans le stockage local du navigateur
            function saveData() {
                // On ne peut pas sauvegarder les objets Leaflet directement. On extrait les donn√©es utiles.
                const savableItems = recordedItems.map(item => {
                    const data = { id: item.id, name: item.name, type: item.type };
                    if (item.type === 'point') { data.coords = item.layer.getLatLng(); } 
                    else if (item.type === 'track') { data.coords = item.layer.getLatLngs(); }
                    return data;
                });
                // On convertit l'objet en texte JSON pour le stocker
                localStorage.setItem('geoTrackerData', JSON.stringify(savableItems));
            }

            // Charge les donn√©es depuis le stockage local au d√©marrage de l'application
            function loadData() {
                const savedData = localStorage.getItem('geoTrackerData');
                if (!savedData) return; // Aucune donn√©e √† charger

                try {
                    const parsedItems = JSON.parse(savedData);
                    let maxId = 0;

                    // On recr√©e les objets Leaflet (marqueurs, trac√©s) √† partir des donn√©es sauvegard√©es
                    parsedItems.forEach(savedItem => {
                        let layer;
                        if (savedItem.type === 'point') { 
                            layer = L.marker(savedItem.coords).addTo(map).bindPopup(savedItem.name); 
                        } else { 
                            layer = L.polyline(savedItem.coords, { color: 'red', weight: 4 }).addTo(map); 
                        }
                        recordedItems.push({ id: savedItem.id, name: savedItem.name, type: savedItem.type, layer: layer });
                        
                        // On s'assure que les nouveaux ID ne cr√©ent pas de conflit
                        const idNum = parseInt(savedItem.id.split('-')[1]);
                        if (idNum > maxId) maxId = idNum;
                    });
                    itemIdCounter = maxId;
                    updateItemList(); // On met √† jour la liste dans le menu
                } catch (e) {
                    console.error("Erreur lors du chargement des donn√©es locales :", e);
                    localStorage.removeItem('geoTrackerData'); // Nettoyer les donn√©es corrompues
                }
            }


            // --- SECTION 5 : LOGIQUE APPLICATIVE (Boutons et Enregistrement) ---

            // G√®re le clic sur le bouton d'enregistrement
            toggleRecordBtn.addEventListener('click', function() {
                isRecording = !isRecording;
                this.textContent = isRecording ? 'Detener Grabaci√≥n' : 'Iniciar Grabaci√≥n';
                this.style.backgroundColor = isRecording ? '#dc3545' : '#007BFF';
                
                if (isRecording) {
                    startNewTrack();
                    showNotification('Grabaci√≥n iniciada.');
                } else {
                    const trackToFinalize = currentTrack;
                    currentTrack = null; 
                    
                    // Si le parcours est trop court, on le supprime
                    if (trackToFinalize && trackToFinalize.getLatLngs().length < 2) {
                        const itemToRemove = recordedItems.pop();
                        if (itemToRemove) map.removeLayer(itemToRemove.layer);
                        updateItemList();
                        showNotification('Grabaci√≥n detenida. Recorrido demasiado corto.', 'error');
                    } else {
                        showNotification('Recorrido finalizado y guardado.');
                    }
                    saveData(); // On sauvegarde dans tous les cas
                }
            });

            // Cr√©e un nouveau trac√© vide
            function startNewTrack() {
                const id = `track-${++itemIdCounter}`;
                const trackName = `Recorrido ${itemIdCounter}`;
                currentTrack = L.polyline([], { color: 'red', weight: 4 }).addTo(map);
                recordedItems.push({ id, name: trackName, type: 'track', layer: currentTrack });
                updateItemList();
            }

            // G√®re le clic sur le bouton de cr√©ation de point
            addPointBtn.addEventListener('click', function() {
                if (!directionMarker) return showNotification('Posici√≥n no encontrada.', 'error');
                const id = `point-${++itemIdCounter}`;
                const pointName = `Punto ${itemIdCounter}`;
                const latlng = directionMarker.getLatLng();
                const point = L.marker(latlng).addTo(map).bindPopup(pointName);
                recordedItems.push({ id, name: pointName, type: 'point', layer: point });
                updateItemList();
                saveData();
                showNotification(`Nuevo punto creado: ${pointName}`);
            });

            // G√®re le clic sur le bouton "Tout Supprimer"
            deleteAllBtn.addEventListener('click', function() {
                if (recordedItems.length === 0) return showNotification('No hay nada que borrar.', 'error');
                if (confirm('¬øEst√°s seguro de que quieres borrar todos los elementos?')) {
                    recordedItems.forEach(item => { if (item.layer) map.removeLayer(item.layer); });
                    recordedItems = [];
                    itemIdCounter = 0;
                    updateItemList();
                    saveData();
                    showNotification('Todos los elementos han sido borrados.');
                }
            });


            // --- SECTION 6 : GESTION DE L'INTERFACE (Menu, Liste, Notifications) ---

            // Met √† jour la liste des √©l√©ments dans le menu lat√©ral
            function updateItemList() {
                itemList.innerHTML = '';
                recordedItems.forEach(item => {
                    const li = document.createElement('li');
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'item-name';
                    nameSpan.textContent = item.name;

                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'item-actions';
                    
                    // Bouton Renommer
                    const renameBtn = document.createElement('button');
                    renameBtn.textContent = '‚úèÔ∏è';
                    renameBtn.className = 'rename-btn';
                    renameBtn.title = 'Renombrar';
                    renameBtn.onclick = function() {
                        const newName = prompt('Introduce el nuevo nombre:', item.name);
                        if (newName && newName.trim()) {
                            item.name = newName.trim();
                            if (item.layer.getPopup()) {
                                item.layer.setPopupContent(item.name);
                            } else {
                                item.layer.bindPopup(item.name);
                            }
                            updateItemList();
                            saveData();
                            showNotification('Elemento renombrado.');
                        }
                    };

                    // Bouton Supprimer
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'üóëÔ∏è';
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.title = 'Borrar';
                    deleteBtn.onclick = function() {
                        map.removeLayer(item.layer);
                        recordedItems = recordedItems.filter(i => i.id !== item.id);
                        updateItemList();
                        saveData();
                        showNotification(`'${item.name}' ha sido borrado.`);
                    };

                    actionsDiv.appendChild(renameBtn);
                    actionsDiv.appendChild(deleteBtn);
                    li.appendChild(nameSpan);
                    li.appendChild(actionsDiv);
                    itemList.appendChild(li);
                });
            }

            // Affiche une notification (toast) √† l'√©cran
            function showNotification(message, type = 'success') {
                const notif = document.createElement('div');
                notif.className = `toast-notification ${type}`;
                notif.textContent = message;
                notificationContainer.appendChild(notif);
                requestAnimationFrame(() => notif.classList.add('show'));
                setTimeout(() => {
                    notif.classList.remove('show');
                    notif.addEventListener('transitionend', () => notif.remove(), { once: true });
                }, 3500);
            }

            // Fonctions pour ouvrir et fermer le menu
            function openMenu() { menu.classList.add('open'); mapOverlay.classList.add('visible'); }
            function closeMenu() { menu.classList.remove('open'); mapOverlay.classList.remove('visible'); }
            menuCloseBtn.addEventListener('click', closeMenu);
            menuToggleBtn.addEventListener('click', (e) => { e.stopPropagation(); openMenu(); });
            mapOverlay.addEventListener('click', closeMenu);
            
            // Le partage de fichier est plus fiable s'il est g√©r√© par le code natif.
            // Ce bouton affiche un message informatif.
            exportShareBtn.addEventListener('click', function() {
                showNotification('Esta funci√≥n debe ser manejada por la app nativa.', 'error');
            });
            
            // --- D√âMARRAGE DE L'APPLICATION ---
            loadData();
        });
    </script>
</body>
</html>